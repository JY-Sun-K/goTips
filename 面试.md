# go基础

1. Go 是强类型（Strongly Typed）语言，因此不允许某一类型的变量赋值为其他类型的值。

2. Golang 是一种编译型语言。源代码会编译为二进制机器码。

3. 使用 **%T** 格式说明符（Format Specifier），可以打印出变量的类型。

4. **byte** 是 uint8 的别名。
   **rune** 是 int32 的别名。
   
5. Go 有着非常严格的强类型特征。Go 没有自动类型提升或类型转换。

6. 常量的值会在编译的时候确定。因为函数调用发生在运行时，所以不能将函数的返回值赋值给常量。

7. **var a[3]int** 声明了一个长度为 3 的整型数组。**数组中的所有元素都被自动赋值为数组类型的零值。** 在这种情况下，`a` 是一个整型数组，因此 `a` 的所有元素都被赋值为 `0`，即 int 型的零值。运行上述程序将 **输出** `[0 0 0]`。

8. ### 切片的长度和容量

   切片的长度是切片中的元素数。**切片的容量是从创建切片索引开始的底层数组中元素数。**

9.  如果切片由数组支持，并且数组本身的长度是固定的，那么切片如何具有动态长度。以及内部发生了什么，当新的元素被添加到切片时，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回这个新数组的新切片引用。现在新切片的容量是旧切片的两倍。

10.  如果我们想知道 map 中到底是不是存在这个 `key`，该怎么做：

     ```go
     value, ok := map[key]
     
     ```

11.  **有一点很重要，当使用 `for range` 遍历 map 时，不保证每次执行程序获取的元素顺序相同。**

12.  `%x` 格式限定符用于指定 16 进制编码。上面的程序输出 `48 65 6c 6c 6f 20 57 6f 72 6c 64`。这些打印出来的字符是 "Hello World" 以 Unicode UTF-8 编码的结果。

13.  rune 是 Go 语言的内建类型，它也是 int32 的别称。在 Go 语言中，rune 表示一个代码点。代码点无论占用多少个字节，都可以用一个 rune 来表示。

14.  如果结构体名称以大写字母开头，则它是其他包可以访问的导出类型（Exported Type）。同样，如果结构体里的字段首字母大写，它也能被其他包访问到。

15.  **结构体是值类型。如果它的每一个字段都是可比较的，则该结构体也是可比较的。如果两个结构体变量的对应字段相等，则这两个变量也是相等的**。

16.  Go 不是纯粹的面向对象编程语言，而且Go不支持类。因此，基于类型的方法是一种实现和类相似行为的途径。

17.  相同的名字的方法可以定义在不同的类型上，而相同名字的函数是不被允许的。假设我们有一个 `Square` 和 `Circle` 结构体。可以在 `Square` 和 `Circle` 上分别定义一个 `Area` 方法。见下面的程序。

18.  值接收器和指针接收器之间的区别在于，在指针接收器的方法内部的改变对于调用者是可见的，然而值接收器的情况不是这样的。

19.  一般来说，指针接收器可以使用在：对方法内部的接收器所做的改变应该对调用者可见时。

     指针接收器也可以被使用在如下场景：当拷贝一个结构体的代价过于昂贵时。考虑下一个结构体有很多的字段。在方法内使用这个结构体做为值接收器需要拷贝整个结构体，这是很昂贵的。在这种情况下使用指针接收器，结构体不会被拷贝，只会传递一个指针到方法内部使用。
     
20. **启动一个新的协程时，协程的调用会立即返回。与函数不同，程序控制不会去等待 Go 协程执行完毕。在调用 Go 协程之后，程序控制会立即返回到代码的下一行，忽略该协程的任何返回值。** 

21. **如果希望运行其他 Go 协程，Go 主协程必须继续运行着。如果 Go 主协程终止，则程序终止，于是其他 Go 协程也不会继续运行。** 

22. 发送与接收默认是阻塞的

23. Mutex 用于提供一种加锁机制（Locking Mechanism），可确保在某时刻只有一个协程在临界区运行，以防止出现竞态条件。

24. 所有在 `Lock` 和 `Unlock` 之间的代码，都只能由一个 Go 协程执行，于是就可以避免竞态条件。

